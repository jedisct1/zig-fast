const std = @import("std");
const mem = std.mem;
const assert = std.debug.assert;

const Aes128 = std.crypto.core.aes.Aes128;

// Cryptographic constants
const AES_BLOCK_SIZE: comptime_int = 16;
const AES_KEY_SIZE: comptime_int = 16;
const DERIVED_KEY_SIZE: comptime_int = 32;

/// Deterministic PRNG (Pseudorandom Number Generator) state using AES-128
/// in ECB mode with a counter.
///
/// This PRNG is designed for cryptographic applications where deterministic
/// random number generation is required (e.g., S-box generation). It uses
/// AES-128 encryption of an incrementing counter to produce high-quality
/// random bytes.
///
/// Security properties:
///   - Cryptographically secure when used with a good key
///   - Deterministic (same key + nonce = same output sequence)
///   - Suitable for deriving S-boxes and sequences in FAST cipher
pub const PrngState = struct {
    const Self = @This();

    cipher_ctx: std.crypto.core.aes.AesEncryptCtx(Aes128),
    counter: [AES_BLOCK_SIZE]u8,
    buffer: [AES_BLOCK_SIZE]u8,
    buffer_pos: usize,

    /// Initialize PRNG with key and nonce.
    ///
    /// Parameters:
    ///   - key: 16-byte AES-128 key
    ///   - nonce: 16-byte initial counter value (nonce)
    ///
    /// Returns: Initialized PRNG state ready to generate random bytes
    pub fn init(key: *const [AES_KEY_SIZE]u8, nonce: *const [AES_BLOCK_SIZE]u8) Self {
        assert(key.len == AES_KEY_SIZE);
        assert(nonce.len == AES_BLOCK_SIZE);

        const cipher_ctx = Aes128.initEnc(key.*);
        return Self{
            .cipher_ctx = cipher_ctx,
            .counter = nonce.*,
            .buffer = @splat(0),
            .buffer_pos = AES_BLOCK_SIZE,
        };
    }

    /// Increment the counter (big-endian)
    fn incrementCounter(counter: *[AES_BLOCK_SIZE]u8) void {
        var i: usize = AES_BLOCK_SIZE;
        while (i > 0) {
            i -= 1;
            counter[i] +%= 1;
            if (counter[i] != 0) break;
        }
    }

    /// Get random bytes from the PRNG.
    ///
    /// Fills the output buffer with cryptographically secure random bytes
    /// generated by AES-128 encryption of the internal counter.
    ///
    /// Parameters:
    ///   - self: PRNG state
    ///   - output: Buffer to fill with random bytes
    pub fn getBytes(self: *Self, output: []u8) void {
        var bytes_copied: usize = 0;

        while (bytes_copied < output.len) {
            if (self.buffer_pos >= AES_BLOCK_SIZE) {
                incrementCounter(&self.counter);
                self.cipher_ctx.encrypt(&self.buffer, &self.counter);
                self.buffer_pos = 0;
            }

            const available = AES_BLOCK_SIZE - self.buffer_pos;
            const to_copy = @min(output.len - bytes_copied, available);

            @memcpy(
                output[bytes_copied..][0..to_copy],
                self.buffer[self.buffer_pos..][0..to_copy],
            );
            self.buffer_pos += to_copy;
            bytes_copied += to_copy;
        }
    }

    /// Get next u32 from the PRNG (big-endian).
    ///
    /// Returns: 32-bit random unsigned integer
    pub fn nextU32(self: *Self) u32 {
        var bytes: [4]u8 = undefined;
        self.getBytes(&bytes);
        return mem.readInt(u32, &bytes, .big);
    }

    /// Generate a uniform random number in [0, bound) with no modulo bias.
    ///
    /// Uses Lemire's method for generating unbiased random numbers in a range,
    /// which avoids the modulo bias of naive `rand() % bound` approaches.
    ///
    /// Parameters:
    ///   - self: PRNG state
    ///   - bound: Upper bound (exclusive), must be > 0 for meaningful results
    ///
    /// Returns: Random number uniformly distributed in [0, bound)
    pub fn uniform(self: *Self, bound: u32) u32 {
        if (bound == 0) return 0;
        if (bound == 1) return 0;

        const bound64: u64 = bound;
        const threshold: u32 = @truncate((0 -% bound) % bound);

        while (true) {
            const r = self.nextU32();
            const product: u64 = @as(u64, r) * bound64;
            const low: u32 = @truncate(product);
            if (low >= threshold) {
                return @truncate(product >> 32);
            }
        }
    }

    /// Clean up PRNG state by zeroizing sensitive data.
    ///
    /// Should be called when the PRNG is no longer needed to ensure
    /// cryptographic material doesn't remain in memory.
    pub fn cleanup(self: *Self) void {
        @memset(&self.counter, 0);
        @memset(&self.buffer, 0);
        self.buffer_pos = 0;
    }
};

/// Split 32-byte key material into AES key and IV (initialization vector).
///
/// This function splits derived key material from the PRF into a 16-byte AES key
/// and a 16-byte IV suitable for use with the PRNG. The zeroize_iv_suffix parameter
/// controls whether the last 2 bytes of the IV are zeroed, which affects the
/// randomization behavior.
///
/// Usage:
///   - For S-box generation: zeroize_iv_suffix = false (full 16-byte IV)
///   - For sequence generation: zeroize_iv_suffix = true (14-byte IV + 2 zero bytes)
///
/// Parameters:
///   - key_material: 32 bytes of PRF-derived key material
///   - key_out: Output buffer for 16-byte AES key
///   - iv_out: Output buffer for 16-byte IV
///   - zeroize_iv_suffix: Whether to zero the last 2 bytes of the IV
pub fn splitKeyMaterial(
    key_material: *const [DERIVED_KEY_SIZE]u8,
    key_out: *[AES_KEY_SIZE]u8,
    iv_out: *[AES_BLOCK_SIZE]u8,
    zeroize_iv_suffix: bool,
) void {
    assert(key_material.len == DERIVED_KEY_SIZE);
    assert(key_out.len == AES_KEY_SIZE);
    assert(iv_out.len == AES_BLOCK_SIZE);

    @memcpy(key_out, key_material[0..AES_KEY_SIZE]);
    @memcpy(iv_out, key_material[AES_KEY_SIZE..][0..AES_BLOCK_SIZE]);
    if (zeroize_iv_suffix) {
        iv_out[AES_BLOCK_SIZE - 1] = 0;
        iv_out[AES_BLOCK_SIZE - 2] = 0;
    }
}

/// Generate a sequence of S-box indices using PRF-derived key material.
///
/// This function generates a deterministic sequence of random indices in the
/// range [0, pool_size) for selecting S-boxes during encryption/decryption.
///
/// Parameters:
///   - seq: Output buffer to fill with S-box indices
///   - pool_size: Size of the S-box pool (indices will be in [0, pool_size))
///   - key_material: 32 bytes of PRF-derived key material
pub fn generateSequence(
    seq: []u32,
    pool_size: u32,
    key_material: *const [DERIVED_KEY_SIZE]u8,
) void {
    var key: [AES_KEY_SIZE]u8 = undefined;
    var iv: [AES_BLOCK_SIZE]u8 = undefined;
    splitKeyMaterial(key_material, &key, &iv, true);

    var prng = PrngState.init(&key, &iv);
    defer prng.cleanup();

    for (seq) |*s| {
        s.* = prng.uniform(pool_size);
    }

    @memset(&key, 0);
    @memset(&iv, 0);
}

test "prng basic" {
    const key = [_]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    const nonce: [AES_BLOCK_SIZE]u8 = @splat(0);

    var prng = PrngState.init(&key, &nonce);
    defer prng.cleanup();

    var bytes: [32]u8 = undefined;
    prng.getBytes(&bytes);

    // Just verify it produces bytes
    try std.testing.expect(bytes.len == 32);
}

test "prng uniform" {
    const key = [_]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
        0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    const nonce: [AES_BLOCK_SIZE]u8 = @splat(0);

    var prng = PrngState.init(&key, &nonce);
    defer prng.cleanup();

    // Generate 100 random numbers in [0, 10) and verify they're all in range
    for (0..100) |_| {
        const r = prng.uniform(10);
        try std.testing.expect(r < 10);
    }
}
